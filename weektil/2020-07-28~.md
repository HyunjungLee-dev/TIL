# 2020-07-28

## THREAD

### 들어가며

Process는 Thread라는걸 담는 바구니 Process 내에서 하나의 흐름을 만들어가는 것이 Thread이다.

프로그램을 하나 작성해서 돌렸을 때 메인함수가 호출이 된다. 하나의 프로세스 내에서 하나의 프로세스가 생성이 되고 메인 함수를 호출해서 실행해 갈 수 있는 쓰레드를 하나 만들어서 그 프로그램을 실행시킨 것(원프로세스 원쓰레드), 이때 메인함수를 호출하는 쓰레드를 가리켜 메인 쓰레드라고도 말한다. 

오늘 날 대부분의 운영체제는 멀티쓰레드를 지원한다. 그 뜻은 프로세스 내에서 둘 이상의 스레드 생성이 가능하다라는 것. 하나는 프로그램 실행과 동시에 생성(메인 함수의 호출)이 된다. 즉 메인 쓰레드가 있을 것이고 이것 이외에 별도의 쓰레드를 생성을 해서 별도의 프로그램 흐름을 형성할 수 있다.

이것을 이용하면 이와 같이 서비스가 가능해진다.

서버는 하나의 프로세스, 안의 하나의 스레드가 서버의 기본적인 흐름을 컨트롤 한다. 클라이언트의 요청이 오면 연결 요청에 대한 응답을 하기 위해 하나의 스레드를 생성한다. 또 연결 요청이 들어올때마다 스레드를 생성하게 되는데 이때 만들어진 스레드가 3개라면 동시에 3개의 클라이언트에게 실시간으로 응답해줄수 있는 모델이 되는것이다.  이와 같은 형태로 동작하는 것이 멀티쓰레드이다.

Thread는 경량화 된 프로세스라고 볼 수 있다.

### Thread의 등장배경

**프로세스는 부담스럽다.**

- 프로세스의 생성에는 많은 리소스가 소모된다.
- 일단 프로세스가 생성되면, 프로세스간의 컨텍스트 스위칭으로 인해서 성능이 저하된다.
- **컨텍스트 스위칭**은 프로세스의 정보를 하드디스크에 저장 및 복원하는 일이다.
  - 프로세스A에서 프로세스B로 작업의 과정이 넘어갈때 하드디스크에 프로세스 A가 작업하던 정보들을 가져다 **저장**해야한다. 그리고 하드디스크에 저장되어 있었던 프로세스 B의 정보를 꺼내와서 CPU/메인메모리(에)로 올려놓고(**복원**)  프로그램을 실행해야 한다. 이것이 컨텍스트 스위칭
  - 쓰레드 간의 컨텍스트 스위칭은 일어난다. 다만, 컨텍스트 스위칭에 따른 부담이 프로세스와는 비교할 수 없다.(프로세스는 관련된 데이터를 많이 저장하고 많이 복원하게 된다. 쓰레드는 상대적으로 훨씬 적은양의 데이터를 저장하고 복원한다.  )

**데이터의 교환이 어렵다.**

- 프로세스간 메모리가 독립적으로 운영되기 때문에 프로세스간 데이터 공유 불가능
  - 쓰레드는 메모리를 완전히 독립하지 않는다. 다 공유하되(데이터,힙 영역) 딱 하나 스택만 공유하지 않는다.(별도로 유지, 쓰레드 간의 함수호출(실행의 흐름,정해진 순서의 함수 호출) 은 독립적이다. 자신만의 함수 호출을 가지고 자신만의 프로그램의 흐름을 형성하기 위해서는 스택을 별도로 가질 수 밖에 없는 구조이다.  ) -> 그렇기 때문에 컨텍스트 스위칭을 할때 저장하고 복원하는 양이 비교적 적을 수 밖에 없다.
  - 스택이 하나라고 가정하면 A,B,C 쓰레드가 있을때 각각의 쓰레드의 함수호출이 스택영역에 쌓여갈때 각각 A-1,4/B-2,5/C-3,6 함수를 호출했다고 하면 A가 1번 함수를 호출한 상황에서 4번 함수를 호출했다. 4번 함수 호출이 끝나면 팝업 되어서 사라져야하는데 그 사이에 2번 3번 함수가 스택에 쌓여있어 중간에 팝업 시킬수 없게 됨.
  - 힙이라는 영역은 공유를 하기때문에 동적할당 된 메모리공간의 포인터만 가지고 있다면 동시접근이 가능하다. 전역변수(데이터영역에 할당) 또한 동시접근이 가능하다. 이 둘 뿐만 아니라 코드까지고 공유를 한다. 예를 들어 정의되어있는 하나의 함수가 있을때 그 함수를 동시 호출하는 것도 가능하다.
- 따라서 운영체제가 별도로 제공하는 메모리 공간을 대상으로 별도의 IPC기법 적용

**그렇다면 쓰레드는?**

- 프로세스보다 가벼운, 경량화된 프로세스이다. 때문에 컨텍스트 스위칭이 빠르다.
- 쓰레드 별로 메모리 공유가 가능하기 때문에 별도의 IPC 기법 불필요
- 프로세스 내에서의 프로그램의 흐름을 추가한다.
- 멀티 프로세스 기반의 서버 구현보다 멀티 쓰레드 기반의 서버구현이 논리적인 표현이 수월하다. 

**운영체제와 프로세스, 쓰레드의 관계**

- 기본적으로 멀티프로세스 운영체제는 프로세스를 둘 이상 생성 시킬 수 있으며 프로세스는 쓰레드를 담는 바구니이다. 프로세스 내에서의 실행흐름은 실제로 쓰레드라는 것이 구성을 하고 이 쓰레드는 둘 이상 생성이 될 수 있으며 메인 함수의 호출 조차도 처음에 생성 된 메인쓰레드에 의해 실행이 되고  쓰레드는 프로그램 실행 과정에서 증가 될 수 있다.



# 2020-07-29

## 정렬하여 출력하기

### **C**

printf 함수로 문자(문자열)나 숫자를 출력하면 기본적으로 왼쪽 정렬이 된다. 오른쪽 정렬을 위해서는 공백의 개수를 넣어주면 된다.

%숫자d와 같은 형태로 사용하면 된다.이때  **오른쪽정렬은 %(+)숫자d**, **왼쪽 정렬은 %-숫자d** 로 정렬을 할 수 있다. 또한 공백의 자리에 공백이 아닌 0을 넣고 싶을 경우에는 **%0숫자d**와 같이 적으면 공백의 자리에 0이 들어가게 된다.

여기서 오른쪽 정렬과 같은 경우는 해당 숫자의 앞에 공백을 넣어 오른쪽정렬을 만드는 것이고 왼쪽 정렬 같은 경우에는 뒤에 숫자만큼의 공백을 넣어 왼쪽 정렬을 하게 된다.

```c
int main()
{
	printf("%-10d\n", 30);
	printf("%-10s\n", "Test");

	printf("%10d\n", 30);
	printf("%10s\n", "Test");
	
	printf("%010d\n", 30);
	printf("%010s\n", "Test");

	printf("%-010d\n", 30);
	printf("%-010s\n", "Test");
	
	return 0;
}
```

<img src="https://user-images.githubusercontent.com/54986748/88761786-cc45e680-d1aa-11ea-9bfa-86b89c91e628.PNG" alt="00" style="zoom:150%;" />

### C++

iomanip 헤더에 있는 setw 함수를 사용하면 된다.

cout << setw(n) << "값" 과 같이 사용하며 n만큼 띄우고 출력해준다. 정렬 해주는 코드를 작성하지 않았을 때는 기본 우측 정렬이다. 좌측 또는 우측 정렬을 해주고 싶을 때는  아래와 같은 코드를 먼저 입력해주면 된다.

좌측 정렬 : cout.setf(ios::left)

우측 정렬 : cout.setf(ios::right)

이 내용을 이용하여 [정올 Language_Coder 508 : 출력 - 자가진단8](http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&wr_id=145&sca=10) 문제를 풀수도 있다.



# 2020-07-31

## 쓰레드 생성에 사용되는 함수(Linux)

*참고 : HANDLE CrateThread는 Thread를 생성하는 API이며 C/C++ Runtime 함수는 _beginthreadex 함수*

```c
#include <pthread.h>

int pthread_create(
	pthread_t *restrict thread, const pthread_attr_t *restrict attr, 
	void *(*start_routine)(void*), void *restrict arg
);
	//성공 시 0, 실패 시 0 이외의 값 반환
```

- thread : **생성할 쓰레드의 ID 저장을 위한 변수의 주소 값 전달**, 참고로 쓰레드는 프로세스와 마찬가지로 쓰레드 구분을 위한 ID가 부여된다.

- attr : **쓰레드에 부여할 특성 정보의 전달**을 위한 매개변수, **NULL** 전달 시 기본적인 특성의 쓰레드가 생성된다.

- start_routine : 쓰레드의 main 함수 역할을 하는, 별도 실행흐름의 시작이 되는 함수의 주소 값(함수 포인터) 전달.

  - 메인 쓰레드가 프로그램의 시작을 위해 메인이라는 하나의 함수가 필요한 것처럼 그 이후 추가로 생성 되는 쓰레드들도 자신만의 메인 함수, 보통 쓰레드 함수라고 이야기 하는데 시작점에 해당하는 함수가 필요하다. 그 함수를 직접 만들어야한다. 쓰레드에게 일을 시켜야하는 것 쓰레드를 순수하게 생성하는 것은 운영체제의 몫이지만 위의 함수를 호출을 통해 운영체제에게 쓰레드의 생성을 요청 하는 것이긴 하지만 그 쓰레드가 일을 시키기위한 어떠한 준비는 우리가 해야한다. 

    그 일을 시키기 위해 함수를 하나 정의한다. 그것을 쓰레드 함수라고 얘기를 하고 쓰레드가 생성이 되면 그 쓰레드가 실행을 하는 즉 일의 시작점이 되는 것이다.  그 함수의 주소 값을 인자로 전달을 하는 것이다.

- arg : 세 번째 인자를 통해 등록된 함수가 호출될 때 전달할 인자의 정보를 담고 있는 변수의 주소 값 전달.`void *(*start_routine)(void*)`에서 (void*)

정리 : pthread_create 함수를 호출이 되면 쓰레드가 생성이 된다. 생성 된 쓰레드의 ID는 첫 번째 인자를 통해서 저장이 될 것이다. 세 번재 인자로 전달이 된 함수가 호출이 되는데 이 함수가 호출 될 때 전달하는 인자의 정보는 네 번째 인자를 통해서 전달하게 된다는 것이다. 즉 내가 네 번째 인자를 통해 전달한 매개변수의 정보가 세 번째 인자로 전달 된 함수를 호출할 때 전달이 된다라는 것.

### 예제

```c
int main(int argc, char *argv[])
{
    pthread_t t_id;//쓰레드의 아이디를 저장 하기 위한 변수
    int thread_param = 5;
    
    if(pthread_create(&t_id, NULL, thread_main, (void*)&thread_param) != 0)
    {//여기서 생성 된 쓰레드는 thread_main 함수가 반환이 되면서 종료된다.
        puts("pthread_create() error");
        return -1;
    };
    sleep(10); puts("end of main"); 
    return 0;
}

```

 메인 쓰레드가 종료가 되면 해당 프로세스는 종료가 되어버린다. 그렇기 때문에 메인 쓰레드에서 생성 된 쓰레드도 종료가 되는데  sleep 함수 호출을 통해서 내가 생성한 쓰레드의 실행이 완료 될때까지 프로세스의 종료를 막기 위해서 10초간 main 함수의 실행을 지연시키고 있다.

```c
void* thread_main(void *arg) //반환형이 void형 포인터 매개 변수 형이 void형 포인트인 함수
{
    int i;
    int cnt = *((int*)arg);
    for(i=0; i<cnt; i++)
    {
        slepp(1); puts("running thread");
    }
    return NULL;
}
```

thread_main 함수가 쓰레드의 main 함수이다. 따라서 이를 가리켜 쓰레드 함수라 한다. 쓰레드가 생성되면 생성된 쓰레드는 쓰레드 함수를 실행한다. 쓰레드 함수의 실행이 완료 되면 쓰레드는 종료된다.

`void* thread_main(void *arg)` int형을 데이터를 저장하도록 매개 변수형이 선언 되어 있지 않고 void형 포인터 선언한 이유는 함수를 호출 할 때, 인자의 개수가 2개가 될수도 3개가 될수도 있고 자료형도 다양하다. 그것을 하나의 함수에 다 표현하지 못한다. 이때 void 포인터형으로 선언해놓으면 그것이 두 개이건 세 개이건 특정 메모리 공간에 잘 저장을 한다면 만약에 종류가 너무 다양할 경우는 구조체를 정의 할수도 있고 그 구조체 변수에 내가 필요한 정보를 채워서 그 구조체 변수의 주소 값을 전달을 할수도 있다.  즉, 프로그램 사용자가 원하는 형태로 매개 변수형을 결정해서 주소값을 전달하라는 의미이다. 

컴파일을 할 때는 -lpthread 옵션을 추가하여 쓰레드 라이브러리 링크를 별도 지시해야한다. 리눅스에서 생성하는 쓰레드를 가리켜 pthread라고 한다. 이것은 pthread에 관련 된 라이브러리를 같이 링크해서 컴파일을 완료해서 실행파일을 만들어라라는것 즉, pthread_create라는 함수가 정의가 되어있는 라이브러리를 같이 링크하라라는 뜻이다.

## 프로세스 종료와 쓰레드

**쓰레드의 생성**

프로세스의 메인 쓰레드에서 pthread_create 함수를 호출한다. 메인쓰레드가 먼저 종료가 되고 종료가 될 때까지 쓰레드는 즉 메인 쓰레드는 slee() 함수를 통해서 실행을 일시 중지한다. 그 후 (예제를 예로 들면)10초가 지나서 프로세스가 종료 되는 그런 형태를 띄고 있다. 그리고 여기서 사용 되는 sleep 함수의 호출을 통해서 프로그램의 흐름을 관리하는 데는 한계가 있다.

**쓰레드의 소멸**

쓰레드는 쓰레드의 메인 함수의 실행을 완료하면 쓰레드가 종료가 된다. 이때 여기서 종료가 되는 것이지 쓰레드와 관련 된 모든 리소스가 소멸 되는 것은 아니다. 

### 쓰레드의 종료를 대기

```c
#include<pthread.h>

int pthread_join(pthread_t thread, void **status);
//성공시 0, 실패 시 0 이외의 값 반환
```

- thred : 이 매개변수에 전달되는 ID의 쓰레드가 종료될 때까지 함수는 반환하지 않는다.
- status :  쓰레드의 main 함수가 반환하는 값이 저장될 포인터 변수의 주소 값을 전달한다.
  - 쓰레드도 NULL이 아닌 종류와 관련 된 상태값을 반환 할 수 있다. 그 값을 두 번째 인자전달을 통해 얻게 된다.

메인 쓰레드에서 별도로 생성한 쓰레드의 종료를 대기하기 위해서 sleep 함수를 호출 했었는데 sleep 함수를 호출한다는 것은 쓰레드의 실행 시간을 예측한다는 뜻이 된다. 실제로 예측을 어느정도 할 수는 있지만 상당히 많은 변수가 있고 약간이라도 절차가 체계화 되어버리면(복잡해지면) 쓰레드 실행 순서를 예측할 수가 없다. 또한 실행 시간을 완벽히 예측하는 것은 불가능 하다. 그렇기 때문에 내가 원하는 바를 명시할 수 있어야한다. 예를들어 어떠한 쓰레드의 실행이 종료 할때까지 기다리고 싶다고 하면 그것을 알려줘야지 sleep 함수를 통해서 인위적으로 기다리게 하는 것은 문제가 있다라는 것이다. 이때 그러한 용도로 사용할 수 있는 함수가 정의가 되어있다.

pthread_join 함수는 함수를 호출하면서 그 쓰레드가 종료되기만을 기다리는 그 쓰레드의 ID를 인자로 전달 하면  쓰레드가 종료 될 때까지 실행 되지 않고 대기 상태에 놓이게 된다.

첫 번째 인자로 전달되는 ID의 쓰레드가 종료될 때까지,이 함수를 호출한 프로세스(또는 쓰레드)를 대기상태에 둔다.

```c
int main(int argc, char *argv[])
{
    pthread_t t_id;//쓰레드의 아이디를 저장 하기 위한 변수
    int thread_param = 5;
    void *thr_ret;
    
    if(pthread_create(&t_id, NULL, thread_main, (void*)&thread_param) != 0)
    {//여기서 생성 된 쓰레드는 thread_main 함수가 반환이 되면서 종료된다.
        puts("pthread_create() error");
        return -1;
    };
    
    if(pthread_join(t_id, &thr_ret)!=0)
    {
        puts("pthread_join() error");
        return -1;
    };
    printf("Thread return message : %s \n", (char*)thr_ret);
    free(thr_ret);
    return 0;
}
  
```

```c
void* tread_main(void *arg)
{
    int i;
    int cnt = *((int*)arg);
    char * msg =(char*)malloc(sizeof(char)*50);
    strcpy(msg, "Hello, I'am thread~ \n");
    
    for(i=0; i<cnt; i++)
    {
        sleep(1); puts("running thread");
    }
    return (void*)msg;//문자열의 주소 값을 반환
}
```

pthread_join 함수의 두 번째 매개변수는 더블 포인터이다. 그래서 포인터의 주소값을 전달한다. thread_main에서 보면 malloc 함수를 이용해서 메모리 공간을 별도로 할당하였다. 여기서 왜 malloc 함수를 호출을 진행하는 것이냐면 함수는 종료가 되면 그 안에 선언 된 지역변수는 소멸 되어버린다. 함수가 끝나서도 메모리 공간에 남아 있으려면 전역변수 아니면 동적할당 즉 힙영역을 활용해야한다. 이경우에는 malloc을 통해 문자열을 담고 있는 것이다. 또한 주소 값을 저장하기 위한 메모리 공간은 포인터 변수여야한다(thr_ret) 포인터 변수를 그냥 안넘기고 &를 붙이는 이유는 반환 값을 저장해야하기 때문에 주소 값을 전달하는 것.