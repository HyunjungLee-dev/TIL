# 2020-07-28

## THREAD

### 들어가며

Process는 Thread라는걸 담는 바구니 Process 내에서 하나의 흐름을 만들어가는 것이 Thread이다.

프로그램을 하나 작성해서 돌렸을 때 메인함수가 호출이 된다. 하나의 프로세스 내에서 하나의 프로세스가 생성이 되고 메인 함수를 호출해서 실행해 갈 수 있는 쓰레드를 하나 만들어서 그 프로그램을 실행시킨 것(원프로세스 원쓰레드), 이때 메인함수를 호출하는 쓰레드를 가리켜 메인 쓰레드라고도 말한다. 

오늘 날 대부분의 운영체제는 멀티쓰레드를 지원한다. 그 뜻은 프로세스 내에서 둘 이상의 스레드 생성이 가능하다라는 것. 하나는 프로그램 실행과 동시에 생성(메인 함수의 호출)이 된다. 즉 메인 쓰레드가 있을 것이고 이것 이외에 별도의 쓰레드를 생성을 해서 별도의 프로그램 흐름을 형성할 수 있다.

이것을 이용하면 이와 같이 서비스가 가능해진다.

서버는 하나의 프로세스, 안의 하나의 스레드가 서버의 기본적인 흐름을 컨트롤 한다. 클라이언트의 요청이 오면 연결 요청에 대한 응답을 하기 위해 하나의 스레드를 생성한다. 또 연결 요청이 들어올때마다 스레드를 생성하게 되는데 이때 만들어진 스레드가 3개라면 동시에 3개의 클라이언트에게 실시간으로 응답해줄수 있는 모델이 되는것이다.  이와 같은 형태로 동작하는 것이 멀티쓰레드이다.

Thread는 경량화 된 프로세스라고 볼 수 있다.

### Thread의 등장배경

**프로세스는 부담스럽다.**

- 프로세스의 생성에는 많은 리소스가 소모된다.
- 일단 프로세스가 생성되면, 프로세스간의 컨텍스트 스위칭으로 인해서 성능이 저하된다.
- **컨텍스트 스위칭**은 프로세스의 정보를 하드디스크에 저장 및 복원하는 일이다.
  - 프로세스A에서 프로세스B로 작업의 과정이 넘어갈때 하드디스크에 프로세스 A가 작업하던 정보들을 가져다 **저장**해야한다. 그리고 하드디스크에 저장되어 있었던 프로세스 B의 정보를 꺼내와서 CPU/메인메모리(에)로 올려놓고(**복원**)  프로그램을 실행해야 한다. 이것이 컨텍스트 스위칭
  - 쓰레드 간의 컨텍스트 스위칭은 일어난다. 다만, 컨텍스트 스위칭에 따른 부담이 프로세스와는 비교할 수 없다.(프로세스는 관련된 데이터를 많이 저장하고 많이 복원하게 된다. 쓰레드는 상대적으로 훨씬 적은양의 데이터를 저장하고 복원한다.  )

**데이터의 교환이 어렵다.**

- 프로세스간 메모리가 독립적으로 운영되기 때문에 프로세스간 데이터 공유 불가능
  - 쓰레드는 메모리를 완전히 독립하지 않는다. 다 공유하되(데이터,힙 영역) 딱 하나 스택만 공유하지 않는다.(별도로 유지, 쓰레드 간의 함수호출(실행의 흐름,정해진 순서의 함수 호출) 은 독립적이다. 자신만의 함수 호출을 가지고 자신만의 프로그램의 흐름을 형성하기 위해서는 스택을 별도로 가질 수 밖에 없는 구조이다.  ) -> 그렇기 때문에 컨텍스트 스위칭을 할때 저장하고 복원하는 양이 비교적 적을 수 밖에 없다.
  - 스택이 하나라고 가정하면 A,B,C 쓰레드가 있을때 각각의 쓰레드의 함수호출이 스택영역에 쌓여갈때 각각 A-1,4/B-2,5/C-3,6 함수를 호출했다고 하면 A가 1번 함수를 호출한 상황에서 4번 함수를 호출했다. 4번 함수 호출이 끝나면 팝업 되어서 사라져야하는데 그 사이에 2번 3번 함수가 스택에 쌓여있어 중간에 팝업 시킬수 없게 됨.
  - 힙이라는 영역은 공유를 하기때문에 동적할당 된 메모리공간의 포인터만 가지고 있다면 동시접근이 가능하다. 전역변수(데이터영역에 할당) 또한 동시접근이 가능하다. 이 둘 뿐만 아니라 코드까지고 공유를 한다. 예를 들어 정의되어있는 하나의 함수가 있을때 그 함수를 동시 호출하는 것도 가능하다.
- 따라서 운영체제가 별도로 제공하는 메모리 공간을 대상으로 별도의 IPC기법 적용

**그렇다면 쓰레드는?**

- 프로세스보다 가벼운, 경량화된 프로세스이다. 때문에 컨텍스트 스위칭이 빠르다.
- 쓰레드 별로 메모리 공유가 가능하기 때문에 별도의 IPC 기법 불필요
- 프로세스 내에서의 프로그램의 흐름을 추가한다.
- 멀티 프로세스 기반의 서버 구현보다 멀티 쓰레드 기반의 서버구현이 논리적인 표현이 수월하다. 

**운영체제와 프로세스, 쓰레드이 관계**

- 기본적으로 멀티프로세스 운영체제는 프로세스를 둘 이상 생성 시킬 수 있으며 프로세스는 쓰레드를 담는 바구니이다. 프로세스 내에서의 실행흐름은 실제로 쓰레드라는 것이 구성을 하고 이 쓰레드는 둘 이상 생성이 될 수 있으며 메인 함수의 호출 조차도 처음에 생성 된 메인쓰레드에 의해 실행이 되고  쓰레드는 프로그램 실행 과정에서 증가 될 수 있다.

### 쓰레드 생성에 사용되는 함수(Linux)

*참고 : HANDLE CrateThread는 Thread를 생성하는 API이며 C/C++ Runtime 함수는 _beginthreadex 함수*

```c
#include <pthread.h>

int pthread_create(
	pthread_t *restrict thread, const pthread_attr_t *restrict attr, 
	void *(*start_routine)(void*), void *restrict arg
);
	//성공 시 0, 실패 시 0 이외의 값 반환
```

- thread : **생성할 쓰레드의 ID 저장을 위한 변수의 주소 값 전달**, 참고로 쓰레드는 프로세스와 마찬가지로 쓰레드 구분을 위한 ID가 부여된다.
- attr : **쓰레드에 부여할 특성 정보의 전달**을 위한 매개변수, **NULL** 전달 시 기본적인 특성의 쓰레드가 생성된다.
- start_routine : 쓰레드의 main 함수 역할을 하는, 별도 실행흐름의 시작이 되는 함수의 주소 값(함수 포인터) 전달.
- arg : 세 번째 인자를 통해 등록된 함수가 호출될 때 전달할 인자의 정보를 담고 있는 변수의 주소 값 전달.`void *(*start_routine)(void*)`에서 (void*)



# 2020-07-29

## 정렬하여 출력하기

### **C**

printf 함수로 문자(문자열)나 숫자를 출력하면 기본적으로 왼쪽 정렬이 된다. 오른쪽 정렬을 위해서는 공백의 개수를 넣어주면 된다.

%숫자d와 같은 형태로 사용하면 된다.이때  **오른쪽정렬은 %(+)숫자d**, **왼쪽 정렬은 %-숫자d** 로 정렬을 할 수 있다. 또한 공백의 자리에 공백이 아닌 0을 넣고 싶을 경우에는 **%0숫자d**와 같이 적으면 공백의 자리에 0이 들어가게 된다.

여기서 오른쪽 정렬과 같은 경우는 해당 숫자의 앞에 공백을 넣어 오른쪽정렬을 만드는 것이고 왼쪽 정렬 같은 경우에는 뒤에 숫자만큼의 공백을 넣어 왼쪽 정렬을 하게 된다.

```c
int main()
{
	printf("%-10d\n", 30);
	printf("%-10s\n", "Test");

	printf("%10d\n", 30);
	printf("%10s\n", "Test");
	
	printf("%010d\n", 30);
	printf("%010s\n", "Test");

	printf("%-010d\n", 30);
	printf("%-010s\n", "Test");
	
	return 0;
}
```

<img src="https://user-images.githubusercontent.com/54986748/88761786-cc45e680-d1aa-11ea-9bfa-86b89c91e628.PNG" alt="00" style="zoom:150%;" />

### C++

iomanip 헤더에 있는 setw 함수를 사용하면 된다.

cout << setw(n) << "값" 과 같이 사용하며 n만큼 띄우고 출력해준다. 정렬 해주는 코드를 작성하지 않았을 때는 기본 우측 정렬이다. 좌측 또는 우측 정렬을 해주고 싶을 때는  아래와 같은 코드를 먼저 입력해주면 된다.

좌측 정렬 : cout.setf(ios::left)

우측 정렬 : cout.setf(ios::right)

이 내용을 이용하여 [정올 Language_Coder 508 : 출력 - 자가진단8](http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&wr_id=145&sca=10) 문제를 풀수도 있다.