# 재귀(Recursion)

## 함수의 재귀적 호출

### 재귀함수의 이해

재귀함수란 다음과 같이 함수 내에서 자기 자신을 다시 호출하는 함수를 의미한다.

```c
void Recursive(void)
{
	printf("Recursive call! \n");
	Recursive();
}
```

> "Recursive" 함수를 실행하는 중간에 다시 Recursive 함수가 호출되면, Recursive 함수의 복자본을 하나 더 만들어서 복사본을 실행하게 됩니다."

재진입의 개념으로 보지 말고 복사본이 실행 된다고 생각하자. 호출원리 가능/불가능이라고 생각하지 보다는 지원하는 것이고 지원을 어떤 형태로 하는가에 대해 생각하고 복사본이라고 생각하자. 실제로 함수를 구성하는 명령문은 CPU로 이동 되어(복사 되어) 실행이 된다. 또한 제일 첫번째로 호출 된 함수가 가장 마지막에 종료가 되는 특성을 가지고 있다.

```c
void Recursive(void)
{
	if(num <= 0) //재귀의 탈출조건
		return; // 재귀의 탈출!
	printf("Recursive call! \n");
	Recursive(num-1);
}
```

탈출조건을 반드시 명시해야한다. 그렇지 않으면 한번 호출되면 계속 호출되는 무한반복하게 된다. 

### 재귀함수의 디자인 사례

재귀함수가 있기에 재귀적인 수학적 수식을 그대로 코드로 옮길 수 있다. 이러한 재귀함수의 특징을 보이기 위해 팩토리얼 값을 반환하는 함수를 재귀적으로 구현해보자. 정수  n의 팩토리얼은 n!로 표시한다.

`n! = n x (n-1) x (n-2) x (n-3) x .... x 2 x 1`  ▶ `n! = n x (n-1)!`

n팩토리얼 f(n)은 수식적으로 다음과 같이 표현할 수 있다.

`f(n) = n x f(n-1)(n≧1) / 1 (n=0)`

f(0)에 해당하는 0!이 1이므로 재귀함수의 탈출조건이 된다.

```c
int Factorial(int n)
{
	if(n == 0)
		return 1;
	else
		return n * Factorial(n-1);
}
```



