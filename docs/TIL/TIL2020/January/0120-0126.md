### 01.20

#### 양방향 연결 리스트(Double LinkedList )

이중 연결 리스트라고 부르기도 하며 왼쪽 Node가 오른쪽 Node를 가리킴과 동시에 오른쪽 Node도 왼쪽 Node를 가리키는 구조이다. 왼쪽과 오른쪽 모두 가리키고 있기 때문에 단순 연결리스트에서 참조를 위해 사용했던 before 은 필요가 없다.

삽입을 할 때 두 번째 이후에 Node를 추가할 때 head의 위치를 옮기는 것은 새롭게 추가한 Node를 기존의 head가 가리키는 Node와 연결한 후에 head를 옮겨주는 것이 옳다. 아니면 무엇을 가리켜야 할지 모르게 되게 때문이다.

양방향 연결 리스트에서 Node의 왼쪽으로 이동해서 해당 Node를 참조/삭제 할 수 있는데 이것이 뒤에 나오는 자료구조(스택/큐)를 이해하는데 도움이 될 것이다.

**과제**

<연결 리스트 만들어보기>

1. 양방향 연결 리스트
2. 더미 노드가 리스트의 앞과 뒤에 각각 존재
3. 포인터 변수 head와 tail이 있어 리스트의 앞과 뒤를 각각 가리킨다.



------

### 01.21

#### 양방향 연결 리스트(Double LinkedList )_Dummy Node

기존의 양방향 연결 리스트에서 더미노드 기반 연결 리스트를 구현할 때 코드를 추가/변경 해야하는 부분

**초기화**

더미 노드를 생성하고 head->prev / tail->next를 NULL로 초기화 시켜준다. 양방향 연결 리스트 이므로 head->next는 tail을 가르키게 되고 tail->prev는 head를 가리키게 된다.

**데이터 저장**

새 노드를 추가하는데 달라진 부분은 서로를 가리키게 해야한다는 것이다. 기존과 같이 새 노드를 생성하고 데이터를 저장한 다음 새 노드와 새 노드의 왼쪽에 위치할 노드가 서로를 가리키고 새 노드와  새 노드의 오른쪽에 위치할 노드가 서로를 가리키게 한다.

**조회**

tail이 존재하는만큼 현재 위치(cur  / 첫 조회의 경우는 head)의 다음이 tail인지 확인해야한다. tail일 경우는 더이상 찾을게 없다는 의미임으로 false를 반환한다.  아닌 경우는 현 위치를 다음으로 옮겨주며 데이터 값을 조회한다.

**삭제**

기존의 리스트들과 동일하게 삭제해야하는 노드를 알기 위해 노드를 하나 만들어 저장해준다 다음 삭제 하는 현 노드의 앞과 뒤에 있는 노드를 각각 연결해준다. 그 후 현재 위치를 삭제 하는 현 노드의 앞의 노드로 바꿔준다(앞인 이유는 뒤의 노드로 할 경우 조회시 현 노드는 조회했다고 여겨져 넘어가기 때문이다.) 모든 과정이 끝난후 저장했던 현 노드를 동적할당 해제(삭제)해준다.

여기서 코드를 작성할때, 노드 자체인지 아니면  next인지 prev인지 생각하자. 그림을 그려보는 것이 많은 도움이 된다! 



------

### 01.22

#### 스택(Stack) [C언어]

스택이란 후입선출(LIFO-Last In, First Out)방식의 자료 구조이다.  

**스택 자료구조의 ADT**

```C
void StackInit(Stack* pstack);
//스택의 초기화

int SIsEmpty(Stack* pstack);
//스택이 빈 경우 TRUE, 그렇지 않은 경우 FALSE을 반환

void Spush(Stack* pstack, Data data);
// 스택에 데이터를 저장한다.

Data Spop(Stack* pstack);
// 마지막 저장된 요소를 삭제하고 삭제된 데이터는 반환 된다

Data Speek(stack* pstack);
// 마지막 데이터를 반환하되 삭제는 하지 않는다.
```

여기서  c로는 직접 함수를 만들어줘야하는데 위의 ADT 이름에 있는 push, pop, size, empty 로 만들어준 것은 **c++ STL**에서도 볼 수 있다. #include<stack>을 통해서 스택 라이브러리를 include 하여 사용 할 수 있다. 

c++ STL의 경우는 이 사이트를 참고 할 것

http://www.cplusplus.com/reference/stack/stack/stack/

스택의 경우 배열과 연결 리스트 기반으로 구현이 가능하다.  

**배열 기반의 경우**

데이터를 추가하고 꺼내 쓰고 하는 과정만 있어서 리스트 보다 상황이 다양하지 않으며 배열의 길이와 상관없이 인덱스 0이 항상 바닥에 위치한다. 마지막 데이터의 저장 위치를 기억해야한다.

```c
typedef struct _arrayStack
{
Data stackArr[STACK_LEN];
int topIndex;
}ArrayStack;
```

topIndex가 들어가게 된다.  마지막 데이터의 저장 위치를 저장하기 위함이고 초기화에서는 배열은 0부터이기 때문에 -1을 넣어 빈 상태를 만들어줘야한다.

**연결 리스트 기반의 경우**

저장된 정보가 역순으로 조회(삭제)가 가능한 연결 리스트이며 메모리 구조는 똑같은 모양을 하지만 ADT정의에서 함수의 역할이 다르다.

*연결 리스트에서는 저장된 순서를 유지하는 것은 필요 사항이 아니었기에 정렬 함수를 따로 만들었었고 양뱡향 연결리스트에서도 따로 함수를 만들어 Node의 왼쪽으로 이동해서 해당 Node를 참조/삭제 할 수 있었다. 스택의 경우는 자료를 관리한다는 것은 동일하지만 관리 방식(LIFO)이 미리 정해져 있다는 것이 다르다*

#### isdigit 숫자를 판단하는 함수

isdigit 함수는 문자가 숫자 0~9 사이에 속하는지 검사하는 함수이다.

**헤더 파일**

#include <ctype.h> // c

#include <cctype> // c++

함수 원형은 int isdigit(int c); 

문자가 0~9 사이에 속하면 true 아니면 false

#### memset 함수[c/c++]

#include <string.h>

어떤 메모리의 시작점부터 연속된 범위를 어떤 값으로(바이트 단위) 모두 지정하고 싶을 때 사용하는 함수이다.

https://twpower.github.io/79-usage-of-memset-function

#### getline 함수

https://arer.tistory.com/29

#### string 클래스를 정수, 실수로 변경해주는 함수 

https://blockdmask.tistory.com/333

------

