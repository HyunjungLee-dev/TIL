### 01.20

#### 양방향 연결 리스트(Double LinkedList )

이중 연결 리스트라고 부르기도 하며 왼쪽 Node가 오른쪽 Node를 가리킴과 동시에 오른쪽 Node도 왼쪽 Node를 가리키는 구조이다. 왼쪽과 오른쪽 모두 가리키고 있기 때문에 단순 연결리스트에서 참조를 위해 사용했던 before 은 필요가 없다.

삽입을 할 때 두 번째 이후에 Node를 추가할 때 head의 위치를 옮기는 것은 새롭게 추가한 Node를 기존의 head가 가리키는 Node와 연결한 후에 head를 옮겨주는 것이 옳다. 아니면 무엇을 가리켜야 할지 모르게 되게 때문이다.

양방향 연결 리스트에서 Node의 왼쪽으로 이동해서 해당 Node를 참조/삭제 할 수 있는데 이것이 뒤에 나오는 자료구조(스택/큐)를 이해하는데 도움이 될 것이다.

**과제**

<연결 리스트 만들어보기>

1. 양방향 연결 리스트
2. 더미 노드가 리스트의 앞과 뒤에 각각 존재
3. 포인터 변수 head와 tail이 있어 리스트의 앞과 뒤를 각각 가리킨다.



------

### 01.21

#### 양방향 연결 리스트(Double LinkedList )_Dummy Node

기존의 양방향 연결 리스트에서 더미노드 기반 연결 리스트를 구현할 때 코드를 추가/변경 해야하는 부분

**초기화**

더미 노드를 생성하고 head->prev / tail->next를 NULL로 초기화 시켜준다. 양방향 연결 리스트 이므로 head->next는 tail을 가르키게 되고 tail->prev는 head를 가리키게 된다.

**데이터 저장**

새 노드를 추가하는데 달라진 부분은 서로를 가리키게 해야한다는 것이다. 기존과 같이 새 노드를 생성하고 데이터를 저장한 다음 새 노드와 새 노드의 왼쪽에 위치할 노드가 서로를 가리키고 새 노드와  새 노드의 오른쪽에 위치할 노드가 서로를 가리키게 한다.

**조회**

tail이 존재하는만큼 현재 위치(cur  / 첫 조회의 경우는 head)의 다음이 tail인지 확인해야한다. tail일 경우는 더이상 찾을게 없다는 의미임으로 false를 반환한다.  아닌 경우는 현 위치를 다음으로 옮겨주며 데이터 값을 조회한다.

**삭제**

기존의 리스트들과 동일하게 삭제해야하는 노드를 알기 위해 노드를 하나 만들어 저장해준다 다음 삭제 하는 현 노드의 앞과 뒤에 있는 노드를 각각 연결해준다. 그 후 현재 위치를 삭제 하는 현 노드의 앞의 노드로 바꿔준다(앞인 이유는 뒤의 노드로 할 경우 조회시 현 노드는 조회했다고 여겨져 넘어가기 때문이다.) 모든 과정이 끝난후 저장했던 현 노드를 동적할당 해제(삭제)해준다.

여기서 코드를 작성할때, 노드 자체인지 아니면  next인지 prev인지 생각하자. 그림을 그려보는 것이 많은 도움이 된다! 



------

