### 0128

### 큐(Queue)

큐는 선입선출(FIFO : First In, First Out)로 먼저 들어온게 먼저 나가는 자료구조이다. 대기표 같은걸 예로 들 수 있는데 먼저 기다린 사람이 먼저 받는 것처럼 큐 또한 그렇다.

스택에서는 데이터를 넣는 push, 데이터를 꺼내는 pop이 있었다면 큐의 경우는 Enqueue,Dequeue가 있다. 

큐의 ADT 정의를 해보면 스택과 필요 함수가 크게 다르지 않지만 스택은 후입선출, 큐는 선입선출이므로 세부 구현에 대해서는 다른점이 있다.

큐 또한 배열 기반의 큐와 연결리스트 기반의 큐가 있다. 먼저 **배열 기반의 큐**를 살펴보면 데이터가 증가할 때는 뒤에서 붙고 반환할 때는 앞에서 부터 반환하는데 여기서 앞은 Front, 뒤는 Rear가 가리키게 되는데 새 데이터가 추가 될때 Rear의 위치만 움직이게 된다. 하지만 여기서 문제가 있는데 데이터를 삭제할 때 Front는 앞에서부터 제거하게 되게 되는데  배열 자체가 크기가 제한 되어있기 때문에 Front에 삭제 된 빈 공간을 사용하려면 모든 자료를 꺼내거나 자료를 한칸 씩 옮겨야하는 단점이 있다.

이 선형 큐의 문제점을 해결하기 위해 논리적으로 배열의 처음과 끝이 연결 되어 있는 원형으로 본다.  원형 큐의 경우에도  문제점이 있는데 Full과 Empty가 구분이 안된다는 점이다. 처음 시작할 때 Front와 Rear은 같은 곳을 가리키고 있고 모든 공간을 다 사용하여 포화상태가 된 경우에도 결국 같은 곳을 가리키게 되기 때문이다. 따라서 이 문제를 해결하기 위해 하나의 저장공간을 비워두기로 한다. 그렇기 때문에 **큐에서는 다음 위치를 체크해서 위치를 반환하는 함수가 구현의 핵심이다.**

```c
int NextPosIdx(int pos)
{
if (pos == QUE_LEN - 1)
	return 0;
else
	return pos + 1;
}

```

**연결리스트 기반의 큐**는 연결리스트 기반의 스택에서 반환하는 부분만 변경하면 큐가 된다. 선형/원형 큐의 문제점이 해결 되기 때문에  좀 더 쉽게 할 수 있을 것이다. 구현에서 스택에서 변경할 부분을 생각해보면 스택의  push와 pop이 이뤄지는 위치가 같지만 큐는 Enqueue와 Dequeue가 이뤄지는 위치가 다르는 것을 생각할 수 있다.

>  참고 사이트 
>
> https://mailmail.tistory.com/33
>
> https://reakwon.tistory.com/30
>
> https://m.blog.naver.com/powhy123/22100929019

**과제**

- 양방향 연결 리스트 (Double LinkedList)를 스택과 큐를 구현해보기

------

