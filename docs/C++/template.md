# 템플릿(template)

- 여러 타입의 함수나 클래스를 쉽게 구현 가능하게 한다. 
- 프로그램의 속도에 영향을 주지 않지만, 컴파일하는 도중에 클래스나 함수를 생성해야 하므로 컴파일이 느려지는 단점은 있다.
- 함수 템플릿과 클래스 템플릿이 있다.

## 함수 템플릿

함수 템플릿은 함수의 일반화 서술이다. 함수 템플릿은 int형이나 double형과 같은 구체적인 데이터형을 포괄할 수 있는 일반형(generic type)으로 함수를 정의한다. 어떤 데이터형을 템플릿에 매개변수로 전달하면, 컴파일러가 그 데이터형에 맞는 함수를 생성한다.

```
//Template <typename type> function - declarator
Template <typename T> T Max(T a, T b)
{
	return a>b ? a:b;
}
```

- 함수 앞에 `template<T>` 키워드를 붙이면 된다.
- 매개 변수도 `<T>`여야 한다.
- 명시적, 암시적 호출 둘 다 알맞은 형태의 함수로 변형 시키기 때문에 구분할 필요 없다.

예를들어 두 값을 비교하는 함수를 만들어야 한다고 생각해보자. 게임 구현에서 캐릭터 간의 HP를 비교하는 함수를 만들어보자.

```c++
int Max(int a, int b)
{
	return a > b ? a:b;
}
```

int 타입을 비교하는 Max라는 이름의 함수를 하나 만들었다. 그런데 HP 뿐만아니라 경험치를 비교하는 기능도 필요해졌을때 위의 Max 함수를 사용할 수 있을 것이다. 하지만 체력을 저장하는 변수는 int 타입이고 , 경험치를 저장하는 변수의 타입은 float이다. 그렇다면 int 타입의 Max가 아닌 float 타입으로 `float Max(float a, float b)` 새로 만들어주면 될 것이다. 

하지만 체력, 경험치뿐만 아니라 돈을 비교해야 하는데 돈을 저장하는 변수 타입은 `__int64`이다. 오류가 안나기 위해서는 또 `__int64Max(__int64 a, __int64 b)`를 만들어줘야한다.

그렇게 되면 똑같은 로직으로 구현된 함수를 3개나 만들었는데 또 다른 변수 타입을 가진 변수를 비교해야하는 일이 생긴다면 함수를 또 만들어줘야 할 것이고 Max 함수의 구현을 고쳐야 하면 모든 Max 함수를 찾아 고쳐줘야한다. 즉 코드는 커지고 유지보수는 어려워진다는 것이다.

이때 Max 함수를 하나로 만들어주기 위해 함수 템플릿 Max를 만드는 것이다.

```c++
template <typename T> T Max(T a, T b)
{
	return a > b ? a : b;
}
```

이와 같이 템플릿을 사용하게 되면 변수 타입에 따라 함수를 새로 만들지 않아도 된다. template으로 만든 함수를 '함수 템플릿'이라고 한다.

템플릿을 사용하면 Generic Programming을 할 수 있다. 함수 템플릿에서는 함수의 반환 값과 함수 인자인 a와 b의 타입인 int나 float를 T로 Generic화했다.

### 함수 템플릿과 컴파일

하나의 함수 템플릿을 만든 것으로 어떻게 여러 타입의 함수로 사용할 수 있는 것일까? 그 이유는 컴파일하는 과정에 있다. 컴파일할 때 템플릿으로 만든 것은 템플릿으로 만든 함수를 호출하는 부분에서 평가한다. 

컴파일할 때 평가를 하면서 문법적으로 에러가 없는지 검사하고 만약 에러가 있다면 컴파일 에러를 출력해주고 에러가 없으면 관련 코드를 내부적으로 생성하게 된다. 

이렇게 만들어지는 코드는 소스 코드에 만들어지는 것이 아니고 프로그램의 코드 영역에 만들어진다. 컴파일 타임에 함수 템플릿을 평가하고 관련 코드를 만들기 때문에 템플릿을 많이 사용하면 컴파일 시간이 길어질 수 있고 각 타입에 맞는 코드를 만들어내어 실행 파일의 크기도 커질 수 있다.

### Max 함수 템플릿의 개선점

바로 함수 템플릿을 만들 때 템플릿의 인자에 const와 참조를 사용하는 것이다. 위의 Max 함수 템플릿을 개선해보자. Max의 두 인자 값은 함수 내부에서 변경 되지 않는다. 그러니 함수에 const를 사용하여 내부에서 변경하는 것을 명시적으로 막고 Max 함수를 사용하는 사람에게 알리는 역할을 한다.

C++에서 함수 인자의 전달을 빠르게 하는 방법은 참조로 전달하는 것이다. int나 float 같은 작은 타입은 참조로 전달하는 것이 큰 의미가 없지만 구조체나 클래스로 만들어진 크기가 큰 변수를 사용할 때는 참조로 전달하는 것이 훨씬 빠르다. 

```c++
template <typename T> const T& Max(const T& a, const T& b)
{
	return a > b ? a : b;
}
```

#### 복수 typename 

서로 다른 타입의 인자가 들어오면 컴파일러는 템플릿의 파리미터 T를 사용한 함수의 인자 a와 b의 타입을 어떤 타입으로 해야 할지 판단할 수 없다. 그렇기 때문에 이럴때는 typename을 하나가 아닌 복수 개를 사용한다.

```
template <typename T1, typename T2> const T1& Max(const T1& a, const T2& b)
{
	return a > b ? a : b;
}
```

이때 반환 값은 T1의 자료형이 된다.

#### 함수 템플릿의 전문화

함수 템플릿의 전문화(Specialization)라는 특별한 상황에 맞는 함수를 만들면 함수 오버로드와 같이 컴파일러가 상황에 맞는 함수를 선택하도록 한다.

#### 호출 순서의 규칙(최선에서 최악으로)

호출 순서는 다음과 같다.

1. 전문화된 함수와 맞는지 검사
2. 템플릿 함수와 맞는지 검사
3. 일반 함수와 맞는지 검사

위의 순서를 잘 기억하고 전문화 함수를 만들어야한다.

### class T와  typename

```c++
template <class T> const T& Max(const T& a, const T& b)
{
	return a > b ? a : b;
}
```

typename과  class는 기능적으로 다른 것이 아니다. 템플릿이 표준이 되기 전에는 class를 사용했다. 예전에 만들어진 C++ 컴파일러도 템플릿 인자 선언으로 class만 지원했기에 만약 C++ 표준화 전후에 만들어진 컴파일러는 class를 사용해야 한다.

현재의 컴파일러는 class와 typename 둘 다 지원한다. 하지만 class 보다 '타입'을 추상화한 것이라는 의미를 더욱 명확하게 전달하는 typename을 사용하도록 한다.

#### 난-타입(non-type)함수 템플릿

함수 템플릿의 파라미터로 typename만이 아닌 값을 파라미터로 사용할 수도 있다. 예를들어 캐릭터의 HP, 경험치, 돈을 이벤트에서 정해진 값만큼 더해주는 함수 템플릿을 만들어 보자.

```c++
template <typename T, int VAL> T AddValue (T const& CurValue)
{
    return CurValue + VAL;
}
```

난- 타입을 잘 사용하면 템플릿 메타 프로그래밍을 할 때 큰 도움이 된다.

## 클래스 템플릿

- 클래스를 정의하기 위한 메타 클래스 코드
- 템플릿 매개변수 인자를 통해 클래스에 사용될 타입을 결정할 수 있다.

클래스 템플릿을 정의 하는 문법

```
template<typename type>class 클래스 이름
{
	..........
};

template<typename T>class Stack
{
	..........
};
```

정의한 클래스 템플릿을 사용하는 방법

```
Class name <type> 변수명;

Stack<int> kStack;
```











> Reference
>
> - SOULSEEK STL PPT 프롤로그
> - C++ 기초 플러스 6판
> - About STL : C++ STL 프로그래밍

