## 그래프 (Graph)

### 그래프의 이해

그래프 알고리즘은 수학자 오일어에 의해 고안되었는데 쾨니히스베르크의 다리 문제를 풀기 위해 그래프 이론을 사용하였다고 한다. 그래프는 저장보다 표현 방법이고 그 표현 방법을 근거로한 다수의 알고리즘이 별도로 존재한다.

- 정점(Vertex)과 간선(Edge)이 존재하고, 정점과 간선끼리 서로 연결되어 있는 형태
  - 정점 : 연결의 대상이 되는 개체 또는 위치
  - 간선 : 정점 사이의 연결
- 연결되어 있는 객체 간의 관계를 표현 할 수 있는 자료구조(ex. 버스/지하철 노선도)

### 그래프의 종류

- 무방향 그래프(Undirected Graph) : 연결 관계에 있어서 방향성이 없는 그래프
- 방향 그래프(Directed Graph) : 간선에 방향정보가 포함된 그래프이며 다이그래프(digraph)라고도 한다.
- 완전 그래프(Complete Graph) : 무방향/방향 그래프는 간선의 연결형태에 따라서 완전 그래프로 구분 되는데 각각의 정점에서 다른 모든 정점을 연결한 그래프를 뜻한다. 정점의 수가 동일한 완전 그래프라고 하여도 방향그래프의 간선의 수는 무방형 그래픠의 간선의 수에 두 배가 된다.
- 가중치 그래프(Weighted Graph) : 가중치는 필요한 경우에 의미를 부여하여 숫자화 시킨다. 예를들면 두 정점 사이의 거리라던가 두 정점을 이동하는데 걸리는 시간과 같은 정보가 될 수 있다.  무방향 그래프에도 방향 그래프에도 부여할 수 있다. 
  - 부분 그래프 : 부분 집합과 유사한 개념으로 부분 그래프는 원 그래프의 일부 정점 및 간선으로 이루어진 그래프를 의미한다.
- 연결 그래프(Connected Graph)
- 비연결 그래프(Disconnected Graph)
- 사이클 (Cycle)
- 비순환 그래프(Acycllic Graph) 

### 그래프의 집합 표현

그래프는 정점과 간선의 집합이기에 집합의 표기법을 이용해서 표현할 수 있다. 

그래프 G가 있을 때, 그래프 G의 정점 집합의 경우 V(G)로 표시하며 간선 집합은 E(G)로 표시한다.

- 무방향 그래프 : 정점 A와 정점 B를 연결하는 간선을 (A,B)로 표시한다. 무방향 그래프의 간선에는 방향성이 없으므로 (A,B)와 (B,A)는 같은 간선을 나타낸다.
  - Ex. `V(G1) = {A,B,C,D}` `E(G1) = {(A,B), (A,C), (A,D), (B,C), (C,D)}`
- 방향 그래프  :  정점 A와 정점 B를 연결하는 간선을 <A,B>로 표시한다.
  - Ex. `V(G1) = {A,B,C,D}` `E(G1) = {<A,B>, <A,C>, <D,A>}`

### 그래프의 ADT

- 생성 및 초기화 할 때 간선의 방향성 여부를 선택할 수 있고, 가중치의 부여 여부도 선택할 수 있으며, 이후에는 정점과 간선을 얼마든지 언제든지 삭제 할 수 있다.
- 구성에 있어 표현하는 부분을 먼저 구성 한 후 필요한 부분을 완성한다.
- 그래프의 표현이 목적이다. 
- ADT 구현에 있어서 모든 기능과 가능성을 담아서  ADT를 정의할 필요는 없다. 실제 실무에서도 구하고자 하는 그래프가 명확하게 있다. 그렇기에 특정 그래프를 대상으로 ADT를 제한하여 정의하는 것이 현명 할 수 있다.

```
void GraphInit(UALGraph* pg, int nv);
- 그래프의 초기화를 진행
- 두 번째 인자로 정점의 수를 전달

void GraphDesroty(UALGraph* pg);
- 그래프 초기화 과정에서 할당한 리소스를 반환한다.

void AddEdge(UAL Graph* pg, int fromV, int toV);
- 매개변수  formV와 toV로 전달된 정점을 연결하는 간선을 그래프에 추가한다.

void ShowGraphEdgeInfo(UALGraph * pg);
-그래프의 간선 정보를 출력한다.

```

**정점의 이름 선언하는 방법**

그래프의 헤더파일에 열거형 상수를 선언한다.

`enum{A,B,C,D,E,F,G,H,I,J};`

`enum{SEOUL, INCHEON, DAEGU, BUSAN, KWANGJU};`

### 그래프의 구현

그래프를 구열하는 방법도 배열을 이용하는 방법과 연결 리스트를 이용하는 방법으로 나뉜다.

- 인접 행렬(Adjacency Matrix) 기반 그래프 : 정방 행렬을 이용
- 인접 리스트(Adjacency List) 기반 그래프 : 연결 리스트를 활용

### 그래프의 탐색

- 리스트와 트리와는 다르게 정점의 구성뿐만 아니라, 간선의 연결에도 규칙적인 연결구조가 없기 때문에 탐색 과정이 제일 어려운 구조이다.
- 그래프의 탐색은 무엇을 찾는다는 것보다는 모든 정점에 한번씩  어떻게 접근을 할지에 대해 생각해봐야한다.
- 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS) 방법이 존재한다.

#### 깊이 우선의 탐색 **(Depth First Search : DFS)**

- 한 쪽 방향으로 연결된 최대한 끝까지 탐색한 후 다른 연결에 대한 탐색을 각각 진행한다.
- 한 정점에 여러 개의 간선이 있다면 우선순위의 선택은 사용자에게 있다.
- 예를들어 비상 연락망을 생각했을 때 알 수 있는 깊이 우선 탐색 과정의 핵심 세가지
  - 한 사람에게만 연락을 한다.
  - 연락할 사람이 없으면, 자신에게 연락한 사람에게 이를 알린다.
  - 처음 연락을 시작한 사람의 위치에서 연락은 끝이 난다.
    - 시작 정점에 연결 된 다른 정점이 있을 경우 그 정점을 다시 확인하게 된다.  그 정점들을 모두 탐색하고 깊이 우선 탐색이 끝이 난다.

##### 깊이우선 탐색의 구현

- 스택과 배열이 필요요소이다.
- 스택은 경로 정보의 추적을 목적으로 한다.
- 배열은 방문 정보의 기록을 목적으로 한다.

#### 너비 우선 탐색 (Breadth Fist Search : BFS)

- 자신에게 연결된 모든 정점에 탐색을 요청하는 방식.
- 동시에 같은 정점으로 접근할 때는 사용자가 설정해서 우선순위를 정해주면 된다.

##### 너비 우선 탐색의 구현

- 스택 대신 큐를 사용한다.
- 큐는 방문 차례의 기록을 목적으로 한다.
- 배열은 방문 정보의 기록을 목적으로 한다.

> 스택과 큐를 모두 구현 가능한 덱(Deque)도 있다.

 



# References

> - [heejeong Kwon blog](https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html)
> - PPT Chapter 6 그래프
> - 윤성우의 열혈 자료구조

